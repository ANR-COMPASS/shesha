
#General configuration

# path to directory to save matrices and results.
Data_dir = '.'

#On bench or numerical simulation
onbench=True

[modelconfig]

    # central wavelength (in meters)
    wavelength_0 = 783.25e-9

    # Spectral band (in meters) I think should be in percent...
    Delta_wav = 0#10e-9

    # Number of monochromatic images in the spectral band.
    # Ignored if Delta_wav = 0
    # must be odd number
    nb_wav = 3

    #Dimension of science image
    dimScience   = 400  #detector science image size (in pixels)

    # Sampling in the detector science image
    #(lambda/Entrance_pupil_diameter in pixel
    Science_sampling = 7.25

    # pupil diameter (in meters)
    diam_pup_in_m = 8.3e-3

    # pupil diameter (in pixels)
    diam_pup_in_pix = 100

    # overpadding pupil plane factor
    overpadding_pupilplane_factor = 1.0

    # Filename of the instrument entrance pupil
    # "Clear" for no pupil / apodizer
    # "RoundPup" for a round pupil of radius diam_pup_in_m
    # or "RomanPup" for exact HLC Roman Pupil
    # or "RomanPupTHD2" for HLC Roman Pupil on THD
    # or an existing full path .fits name
    # e.g. filename_instr_pup = "/Users/jmazoyer/Desktop/roman_pup_500pix_center4pixels.fits"
    filename_instr_pup = "RoundPup"

    # if the pupil is not clear or round, you can rotate the pupil
    # the rotated pupil will be used for matrix and correction
    # angle in degrees in counter-clockwise direction.
    entrance_pup_rotation = 0

[DMconfig]

    # The lowest the more actuators are considered
    # ratio of energy of the influence function inside the pupil wrt to energy of the influence function
    MinimumSurfaceRatioInThePupil = 0.03

    #############
    ## DM 1
    #############

    #Switch on/off DM1
    DM1_active=False

    #DM model
    DM1_z_position = 23.0e-2# m from the pupil in a collimated beam
    #filename of the actuator influence function
    DM1_filename_actu_infl_fct="Actu_DM32_field=6x6pitch_pitch=22pix.fits"
    
    DM1_Generic=False
    # in the case of a generic DM (DM1_Generic =True), we need 2 parameters 
    # to define the DM: the actuator pitch and the number of actuator N_act1D in one of its principal direction.
    # We need N_act1D > diam_pup_in_m / DM_pitch, so that the DM is larger than the pupil.
    # The DM will then be automatically defined as squared with N_act1DxN_act1D actuators
    # and the puil centered on this DM.
    # careful this not change the  DM1_pitch and the aperture diameter. 
    # If you want to have more actuators in the pupil, you migh want to change those as well

    # if DM1_Generic = True
    DM1_pitch=0.3e-3 #in meter, pitch of the DM (distance between actuators)
    DM1_Nact1D = 34

    # We can also create a specific DM for a given testbed with a file with the relative 
    # position of actuators in the pupil and the position of one of them compared to the pupil.

    # if DM1_Generic = False
    # filename of the grid of actuator positions in unit of pupil diameter with (0,0)=center of the pupil
    # This fits must have PITCHV and PITCHH param in the header
    DM1_filename_grid_actu="Estimated_grid_DM1_20220207_opt7.25.fits"
    #filename to put if not all actuators are active
    DM1_filename_active_actu = "DM1_active_actuators.fits"

    # Error on the model of the DM
    DM1_misregistration = False
    DM1_xerror=0                #x-direction translation in actuator pitch
    DM1_yerror=0                #y-direction translation in actuator pitch
    DM1_angerror=0              #rotation in degree
    DM1_gausserror=0            #influence function size (1=100% error)

    #############
    ## DM 3
    #############

    #Switch on/off DM3
    DM3_active=True

    #DM model

    DM3_z_position = 0# m from the pupil in a collimated beam
    #filename of the actuator influence function
    DM3_filename_actu_infl_fct="Actu_DM32_field=6x6pitch_pitch=22pix.fits"

    DM3_Generic=False

    # in the case of a generic DM (DM1_Generic =True), we need 2 parameters 
    # to define the DM: the actuator pitch and the number of actuator N_act1D in one of its principal direction.
    # We need N_act1D > diam_pup_in_m / DM_pitch, so that the DM is larger than the pupil.
    # The DM will then be automatically defined as squared with N_act1DxN_act1D actuators
    # and the puil centered on this DM.
    # careful this not change the  DM1_pitch and the aperture diameter. 
    # If you want to have more actuators in the pupil, you migh want to change those as well

    # if DM1_Generic = True
    DM3_pitch=0.3e-3 #in meter, pitch of the DM (distance between actuators)
    DM3_Nact1D = 32

    # We can also create a specific DM for a given testbed with a file with the relative 
    # position of actuators in the pupil and the position of one of them compared to the pupil.

    # if DM1_Generic = False
    # filename of the grid of actuator positions in unit of pupil diameter with (0,0)=center of the pupil
    # This fits must have PITCHV and PITCHH param in the header
    DM3_filename_grid_actu="Estimated_grid_DM3_20220207_opt7.25.fits"
    #filename to put if not all actuators are active
    DM3_filename_active_actu = ""


    # Error on the model of the DM
    DM3_misregistration = False
    DM3_xerror=0        #x-direction translation in actuator pitch
    DM3_yerror=0        #y-direction translation in actuator pitch
    DM3_angerror=0      #rotation in degree
    DM3_gausserror=0   #influence function size

[Coronaconfig]


    # Filename of the instrument apodisation pupil
    # (pupil after the DMS at the entrance of the coronagraph in Roman)
    # "Clear" for no apodiser
    # "RoundPup" for a round pupil
    # or an existing full path .fits name.
    # e.g. filename_instr_apod = "/Users/jmazoyer/Desktop/roman_pup_500pix_center4pixels.fits"
    filename_instr_apod = "Clear"

    # if the apodizer is not clear or round, you can rotate the apodizer
    # the rotated apodizer will be used for matrix and correction
    # angle in degrees in counter-clockwise direction.
    apod_pup_rotation = 0

    # Filename of the instrument Lyot stop
    # "Clear" for no LS
    # "RoundPup" for a round LS or radius diam_lyot_in_m
    # "RomanLyot" for HLC Roman Lyot
    # "RomanLyotTHD2" for HLC Roman Lyot on the THD (rescaled and rotated)
    # or an existing full path .fits name
    # e.g. filename_instr_lyot = "/Users/jmazoyer/Desktop/roman_lyot_500pix_center4pixels.fits"
    filename_instr_lyot = "RoundPup"

    # if the lyot stop is not clear or round, you can rotate the lyot pupil
    # the rotated pupil will be used for matrix and correction
    # angle in degrees in counter-clockwise direction.
    lyot_pup_rotation = 0

    # lyot diameter (in meters). 
    # Only use in the case of a RoundPup Lyot stop.
    # not use for propagation. 
    # Current value is 8.035mm = 8.1*0.097 
    # (rayon Lyot * de-zoom entrance pupil plane / Lyopt plane)
    diam_lyot_in_m  = 8.035e-3

    #Can be fqpm or knife, vortex, classiclyot or HLC
    corona_type ='fqpm'

    #If knife
        # where light passes (left, right, top, bottom)
    knife_coro_position = 'right'
        #offset of the   knife in lambda/pupil diameter
    knife_coro_offset = 1.2

    #IF classiclyot or HLC
    #radius of the classical Lyot FPM in lambda/pupil diameter
    rad_lyot_fpm = 2.7

    #if HLC, we define the transmission an phase shift at vawelength0
    transmission_fpm = 4e-4 # in intensity
    phase_fpm = 3.14159265359

    #If FQPM
        # phase error on the pi phase-shift (in rad)
    err_fqpm = 0
        # Achromatic FQPM, if True, else pi*lamda0/lamda
    achrom_fqpm = True

    #If Vortex, define the charge of the vortex
    vortex_charge = 2



[Estimationconfig]

    estimation='Perfect' # FP WF sensing : 'Perfect' or 'pw'

    # Integer. We bin the estimation images used for PW / perfect estim by this factor 
    # this way dimEstim = dimScience / Estim_bin_factor
    # Estim_sampling = Science_sampling / Estim_bin_factor
    # be careful, this raise an error if Estim_sampling < 3
    Estim_bin_factor = 2 
    
    #PW parameters
    #Amplitude of PW probes (in nm)
    amplitudePW = 34

    #Actuators used for PW (DM in pupil plane)
    posprobes = 466,498
    #For DM3
    #posprobes = 392,393, 425

    # Threshold to remove pixels with bad
    # estimation of the electric field
    cut = 2e4
    # cut=5e5 #Knife

[Correctionconfig]
    
    # Dark Hole Mask parameters

    # "circle", "square" or "noDH"
    # Not case sensitive
    DH_shape = "circle"

    #if DH_shape == 'Square'
    # Position of the corners of the DH in lambda/Entrance_pupil_diameter
    corner_pos = 2.7,11.7,-11.7,11.7 # xmin, xmax, ymin, ymax

    #if DH_shape == 'circle'
    # "Full", "Left", "Right", "Top", "Bottom" to select one side of the fov.
    # Not case sensitive
    DH_side = "Full"

    Sep_Min_Max = 3.5,10
    #if circle inner and outer radii of the circle DH size in lambda/D

    #if circle
    circ_offset = 0 # if circ_side != "Full", remove separation closer than circ_offset (in lambda/Entrance_pupil_diameter)
    circ_angle = 15 # if circ_side != "Full", we remove the angles closer than circ_angle (in degrees) from the DH 

    # Actuator basis: currently 'fourier' or 'actuator'
    # Same parameter for all DMs
    # Not case sensitive
    DM_basis = 'actuator'

    # Type of matrix : 'Perfect' of 'SmallPhase'
    # Either 'Perfect' Matrix (exp(i.(phi_DM+phi))) or a 
    # 'SmallPhase' aberration matrix (phi_DM.exp(i.phi))
    # Not case sensitive
    MatrixType = 'SmallPhase'

    #EFC for Electric Field Conjugation
    #or EM for Energy Minimization
    #or SM for Stroke Minimization
    #or steepest
    # Not case sensitive
    correction_algorithm = 'efc'

    #EFC parameters
    Nbmodes_OnTestbed = 600#330
    amplitudeEFC = 17
    regularization='tikhonov' # 'truncation' or 'tikhonov'

[Loopconfig]
    
    #Number of time we recompute the Interaction Matrix
    Number_matrix = 1
    
    # number of iterations in each loop.
    # can be a single integer or a list of integer
    Nbiter_corr = 1,1,2,1,5

    # EFC modes. Can be a single integer or a list of integer.
    # !! Must be of the same size than Nbiter_corr !!
    Nbmode_corr = 1100,800,700,800,700

    # EFC correction gain
    gain=0.6
    
    Linesearch = False # if true, the code will find the best EFC modes for 
                        # each iteration in Nbiter_corr (Nbmode_corr is not used 
                        # in this case). The best modes is chosen in a list automatically
                        # selected depending on hte Number of modes of the system

[SIMUconfig]
    #Simulation close loop parameters
    Name_Experiment = 'First_Simulation'

    #Amplitude aberrations
    set_amplitude_abb=True
    set_random_ampl=False
    ampl_rms = 10 #in % in amplitude (not intensity)
    ampl_rhoc = 4.3
    ampl_slope = 1
    ampl_abb_filename='Amplitude_THD2' # 'Amplitude_THD2' or '' for generic name or full fits path

    #Upstream Phase aberrations
    set_UPphase_abb=True
    set_UPrandom_phase=False
    UPopd_rms = 20e-9 #in meter
    UPphase_rhoc = 4.3
    UPphase_slope = 3
    UPphase_abb_filename = ''

    #Downstream Phase aberrations (in Lyot)
    set_DOphase_abb=False
    set_DOrandom_phase=False
    DOopd_rms = 2e-9 #in meter
    DOphase_rhoc = 4.3
    DOphase_slope = 3
    DOphase_abb_filename = ''

    #photon noise
    photon_noise = False
    nb_photons = 4e10

